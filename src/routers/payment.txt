from schemas.user import Â ChatRequest
from sqlalchemy.orm import Session
from src.configs.config import get_db
from fastapi import APIRouter, Depends,HTTPException,File, UploadFile,Form
from common.app_response import AppResponse
from services.tables import Tables
from configs.utilites import get_current_user
from sqlalchemy import select , insert , update, delete ,exists
# from services.payment import start_payment
from common.app_constants import AppConstants
from src.common.messages import Messages
from uuid import UUID, uuid4
from datetime import datetime
from typing import List, Dict
from decimal import Decimal
from schemas.payment import PaymentRequest
import requests

tables = Tables()
app_response = AppResponse()
router = APIRouter()

# PayPal API credentials and endpoint
PAYPAL_CLIENT_ID = settings.PAYPAL_CLIENT_ID
PAYPAL_SECRET = settings.PAYPAL_CLIENT_SECRET
PAYPAL_API_BASE_URL = "https://api.sandbox.paypal.com" 

@router.post("/payments/start_or_continue")
def start_payment(
Â  Â  request: PaymentRequest, 
Â  Â  db: Session = Depends(get_db), Â # Correctly injecting Session
Â  
):
Â  Â  """Starts a new payment or continues an existing one"""
Â  Â  try:
Â  Â  Â  Â  # Call the service to handle payment logic
Â  Â  Â  Â  payment_response = start_payment(request, db)
Â  Â  Â  Â  return payment_response Â # Returning the payment response
Â  Â  except Exception as e:
Â  Â  Â  Â  raise HTTPException(status_code=500, detail=f"Error: {str(e)}")

# def start_payment(request, db: Session):
# Â  Â  """Handles creating a new payment or continuing an existing one."""
# Â  Â  try:
# Â  Â  Â  Â  print(f"ðŸš€ Payment API Called - Request Data: {request.dict()}")

# Â  Â  Â  Â  # âœ… Generate a new transaction_id if not provided
# Â  Â  Â  Â  if not request.transaction_id:
# Â  Â  Â  Â  Â  Â  transaction_id = str(uuid4()) Â # Generate new UUID for transaction_id
# Â  Â  Â  Â  else:
# Â  Â  Â  Â  Â  Â  transaction_id = request.transaction_id

# Â  Â  Â  Â  # âœ… Check if the user exists (user_id should be valid)
# Â  Â  Â  Â  user_exists = db.execute(select(tables.users.c.id).where(tables.users.c.id == request.user_id)).scalar()
# Â  Â  Â  Â  if not user_exists:
# Â  Â  Â  Â  Â  Â  raise ValueError(f"User ID {request.user_id} not found in users table")

# Â  Â  Â  Â  # âœ… Check if payment with the same transaction_id already exists
# Â  Â  Â  Â  existing_payment = db.execute(
# Â  Â  Â  Â  Â  Â  select(tables.payments.c.id).where(tables.payments.c.transaction_id == transaction_id)
# Â  Â  Â  Â  ).scalar()

# Â  Â  Â  Â  if not existing_payment:
# Â  Â  Â  Â  Â  Â  print(f"ðŸ†• Creating new payment: {transaction_id} for user: {request.user_id}")
# Â  Â  Â  Â  Â  Â  db.execute(
# Â  Â  Â  Â  Â  Â  Â  Â  insert(tables.payments).values(
# Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  user_id=request.user_id,
# Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  amount=request.amount,
# Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  tokens_purchased=request.tokens_purchased,
# Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  transaction_id=transaction_id,
# Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  payment_status=request.payment_status,
# Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  created_at=datetime.now()
# Â  Â  Â  Â  Â  Â  Â  Â  )
# Â  Â  Â  Â  Â  Â  )
# Â  Â  Â  Â  Â  Â  db.commit()

# Â  Â  Â  Â  # âœ… Return the payment details as a response
# Â  Â  Â  Â  payment_details = db.execute(
# Â  Â  Â  Â  Â  Â  select([tables.payments]).where(tables.payments.c.transaction_id == transaction_id)
# Â  Â  Â  Â  ).fetchone()

# Â  Â  Â  Â  payment_response = {
# Â  Â  Â  Â  Â  Â  "transaction_id": payment_details["transaction_id"],
# Â  Â  Â  Â  Â  Â  "user_id": payment_details["user_id"],
# Â  Â  Â  Â  Â  Â  "amount": payment_details["amount"],
# Â  Â  Â  Â  Â  Â  "tokens_purchased": payment_details["tokens_purchased"],
# Â  Â  Â  Â  Â  Â  "payment_status": payment_details["payment_status"],
# Â  Â  Â  Â  Â  Â  "created_at": payment_details["created_at"]
# Â  Â  Â  Â  }

# # Â  Â  Â  Â  payment_response ={
# # Â  Â  Â  "user_id": "3fa85f64-5717-4562-b3fc-2c963f66afa6", Â # Example user ID
# # Â  "amount": 1000, Â # Payment amount in USD
# # Â  "tokens_purchased": 10000, Â # Number of tokens the user is buying
# # Â  "transaction_id": "e2f0f9c8-21fc-4d77-a4f1-b59d8c0d1d58", Â # Use a generated UUID
# # Â  "payment_status": "pending", Â # Default payment status
# # Â  "currency": "USD" Â # Currency being used for payment
# # Â  Â  Â  Â  Â }

# Â  Â  Â  Â  return payment_response

# Â  Â  except Exception as e:
# Â  Â  Â  Â  Â print(f"Error: {e}")
# Â  Â  Â  Â  Â raise Exception(f"Failed to process payment: {str(e)}")
def start_payment(request: PaymentRequest, db: Session):
Â  Â  """Handles creating a new payment or continuing an existing one."""
Â  Â  try:
Â  Â  Â  Â  print(f"ðŸš€ Payment API Called - Request Data: {request.dict()}")

Â  Â  Â  Â  # âœ… Generate a new transaction_id if not provided
Â  Â  Â  Â  if not request.transaction_id:
Â  Â  Â  Â  Â  Â  transaction_id = str(uuid4()) Â # Generate new UUID for transaction_id
Â  Â  Â  Â  else:
Â  Â  Â  Â  Â  Â  transaction_id = request.transaction_id

Â  Â  Â  Â  # âœ… Check if the user exists (user_id should be valid)
Â  Â  Â  Â  user_exists = db.execute(select(tables.users.c.id).where(tables.users.c.id == request.user_id)).scalar()
Â  Â  Â  Â  if not user_exists:
Â  Â  Â  Â  Â  Â  raise HTTPException(status_code=404, detail=f"User ID {request.user_id} not found in users table")

Â  Â  Â  Â  # âœ… Check if payment with the same transaction_id already exists
Â  Â  Â  Â  existing_payment = db.execute(
Â  Â  Â  Â  Â  Â  select(tables.payments.c.id).where(tables.payments.c.transaction_id == transaction_id)
Â  Â  Â  Â  ).scalar()

Â  Â  Â  Â  if existing_payment:
Â  Â  Â  Â  Â  Â  # If payment already exists, return its details
Â  Â  Â  Â  Â  Â  print(f"ðŸ”„ Payment already exists: {transaction_id} for user: {request.user_id}")
Â  Â  Â  Â  Â  Â  payment_details = db.execute(
Â  Â  Â  Â  Â  Â  Â  Â  select(tables.payments).where(tables.payments.c.transaction_id == transaction_id)
Â  Â  Â  Â  Â  Â  ).fetchone()

Â  Â  Â  Â  Â  Â  if payment_details:
Â  Â  Â  Â  Â  Â  Â  Â  payment_response = {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  "transaction_id": payment_details[0], Â # First column: id (change based on actual column order)
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  "user_id": payment_details[1], Â  Â  Â  Â  # Second column: user_id
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  "amount": payment_details[2], Â  Â  Â  Â  Â  # Third column: amount
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  "tokens_purchased": payment_details[3], # Fourth column: tokens_purchased
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  "payment_status": payment_details[4], Â  # Fifth column: payment_status
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  "created_at": payment_details[5], Â  Â  Â  # Sixth column: created_at
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  "payer_email": payment_details[6], Â  Â  Â # Payer email
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  "payment_method": payment_details[7] Â  Â # Payment method
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  return payment_response
Â  Â  Â  Â  Â  Â  else:
Â  Â  Â  Â  Â  Â  Â  Â  raise HTTPException(status_code=404, detail="Payment not found")

Â  Â  Â  Â  # âœ… Create a new payment if no existing payment was found
Â  Â  Â  Â  print(f"ðŸ†• Creating new payment: {transaction_id} for user: {request.user_id}")

Â  Â  Â  Â  # Ensure `payer_email` and `payment_method` are either provided or defaulted
Â  Â  Â  Â  payer_email = request.payer_email if request.payer_email else None
Â  Â  Â  Â  payment_method = request.payment_method if request.payment_method else None

Â  Â  Â  Â  db.execute(
Â  Â  Â  Â  Â  Â  insert(tables.payments).values(
Â  Â  Â  Â  Â  Â  Â  Â  user_id=request.user_id,
Â  Â  Â  Â  Â  Â  Â  Â  amount=request.amount,
Â  Â  Â  Â  Â  Â  Â  Â  tokens_purchased=request.tokens_purchased,
Â  Â  Â  Â  Â  Â  Â  Â  transaction_id=transaction_id,
Â  Â  Â  Â  Â  Â  Â  Â  payment_status=request.payment_status or "pending", Â # Set 'pending' as default if not provided
Â  Â  Â  Â  Â  Â  Â  Â  created_at=datetime.now(),
Â  Â  Â  Â  Â  Â  Â  Â  updated_at=datetime.now(),
Â  Â  Â  Â  Â  Â  Â  Â  payer_email=payer_email, Â # Assign payer email
Â  Â  Â  Â  Â  Â  Â  Â  payment_method=payment_method Â # Assign payment method
Â  Â  Â  Â  Â  Â  )
Â  Â  Â  Â  )
Â  Â  Â  Â  db.commit()

Â  Â  Â  Â  # âœ… Fetch and return the created payment details
Â  Â  Â  Â  payment_details = db.execute(
Â  Â  Â  Â  Â  Â  select(tables.payments).where(tables.payments.c.transaction_id == transaction_id)
Â  Â  Â  Â  ).fetchone()

Â  Â  Â  Â  if payment_details:
Â  Â  Â  Â  Â  Â  payment_response = {
Â  Â  Â  Â  Â  Â  Â  Â  "transaction_id": payment_details[0], Â # First column: id
Â  Â  Â  Â  Â  Â  Â  Â  "user_id": payment_details[1], Â  Â  Â  Â  # Second column: user_id
Â  Â  Â  Â  Â  Â  Â  Â  "amount": payment_details[2], Â  Â  Â  Â  Â  # Third column: amount
Â  Â  Â  Â  Â  Â  Â  Â  "tokens_purchased": payment_details[3], # Fourth column: tokens_purchased
Â  Â  Â  Â  Â  Â  Â  Â  "payment_status": payment_details[4], Â  # Fifth column: payment_status
Â  Â  Â  Â  Â  Â  Â  Â  "created_at": payment_details[5], Â  Â  Â  # Sixth column: created_at
Â  Â  Â  Â  Â  Â  Â  Â  "payer_email": payment_details[6], Â  Â  Â # Payer email
Â  Â  Â  Â  Â  Â  Â  Â  "payment_method": payment_details[7] Â  Â # Payment method
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  return payment_response
Â  Â  Â  Â  else:
Â  Â  Â  Â  Â  Â  raise HTTPException(status_code=404, detail="Payment not found after creation")

Â  Â  except Exception as e:
Â  Â  Â  Â  print(f"Error: {e}")
Â  Â  Â  Â  raise HTTPException(status_code=500, detail=f"Failed to process payment: {str(e)}")

Â  Â  
# Get PayPal OAuth Token
def get_paypal_oauth_token() -> str:
Â  Â  """Fetch PayPal OAuth token using client credentials."""
Â  Â  auth = (PAYPAL_CLIENT_ID, PAYPAL_SECRET)
Â  Â  url = f"{PAYPAL_API_BASE_URL}/v1/oauth2/token"
Â  Â  headers = {
Â  Â  Â  Â  "Accept": "application/json",
Â  Â  Â  Â  "Content-Type": "application/x-www-form-urlencoded"
Â  Â  }
Â  Â  data = {
Â  Â  Â  Â  "grant_type": "client_credentials"
Â  Â  }
Â  Â  response = requests.post(url, headers=headers, data=data, auth=auth)
Â  Â  
Â  Â  if response.status_code == 200:
Â  Â  Â  Â  token = response.json().get("access_token")
Â  Â  Â  Â  return token
Â  Â  else:
Â  Â  Â  Â  raise HTTPException(status_code=500, detail="Failed to get PayPal OAuth token")

# Execute payment
def execute_payment(payment_id: str, payer_id: str) -> Dict:
Â  Â  """Complete the payment after user approval."""
Â  Â  # Get OAuth token
Â  Â  oauth_token = get_paypal_oauth_token()
Â  Â  
Â  Â  # Construct URL to execute the payment
Â  Â  url = f"{PAYPAL_API_BASE_URL}/v1/payments/payment/{payment_id}/execute"
Â  Â  
Â  Â  # Construct the request body
Â  Â  data = {
Â  Â  Â  Â  "payer_id": payer_id
Â  Â  }
Â  Â  
Â  Â  # Headers for the API request
Â  Â  headers = {
Â  Â  Â  Â  "Authorization": f"Bearer {oauth_token}",
Â  Â  Â  Â  "Content-Type": "application/json"
Â  Â  }
Â  Â  
Â  Â  # Make the request to PayPal API
Â  Â  response = requests.post(url, json=data, headers=headers)
Â  Â  
Â  Â  # If the payment is successfully executed
Â  Â  if response.status_code == 200:
Â  Â  Â  Â  return response.json() Â # Return the payment status and details
Â  Â  else:
Â  Â  Â  Â  raise HTTPException(status_code=500, detail=f"Failed to execute payment: {response.text}")

@router.get("/payments/execute")
def execute_payment_handler(paymentId: str, PayerID: str, db: Session = Depends(get_db)):
Â  Â  """Complete the payment after the user has approved it"""
Â  Â  try:
Â  Â  Â  Â  # Execute the payment and return the payment status
Â  Â  Â  Â  payment_status = execute_payment(paymentId, PayerID)
Â  Â  Â  Â  return {"payment_status": payment_status}
Â  Â  except Exception as e:
Â  Â  Â  Â  raise HTTPException(status_code=500, detail=f"Error: {str(e)}")


@router.post("/payments/cancel")
async def cancel_payment(payment_id: str, db: Session = Depends(get_db)):
Â  Â  try:
Â  Â  Â  Â  # Update payment status to 'failed' or 'cancelled' based on business logic
Â  Â  Â  Â  db.execute(
Â  Â  Â  Â  Â  Â  update(tables.payments).where(tables.payments.c.transaction_id == payment_id).values(
Â  Â  Â  Â  Â  Â  Â  Â  payment_status='failed', Â # Or any other status like 'cancelled'
Â  Â  Â  Â  Â  Â  Â  Â  updated_at=datetime.now()
Â  Â  Â  Â  Â  Â  )
Â  Â  Â  Â  )
Â  Â  Â  Â  db.commit()

Â  Â  Â  Â  return {"message": "Payment cancelled successfully", "transaction_id": payment_id}

Â  Â  except Exception as e:
Â  Â  Â  Â  raise HTTPException(status_code=400, detail=f"Error canceling payment: {str(e)}")


@router.get("/payments/status")
async def get_payment_status(transaction_id: str, db: Session = Depends(get_db)):
Â  Â  try:
Â  Â  Â  Â  # Fetch payment details by transaction_id
Â  Â  Â  Â  payment = db.execute(
Â  Â  Â  Â  Â  Â  select(tables.payments).where(tables.payments.c.transaction_id == transaction_id)
Â  Â  Â  Â  ).fetchone()

Â  Â  Â  Â  if not payment:
Â  Â  Â  Â  Â  Â  raise HTTPException(status_code=404, detail="Payment not found")

Â  Â  Â  Â  return {"transaction_id": payment['transaction_id'], "payment_status": payment['payment_status']}

Â  Â  except Exception as e:
Â  Â  Â  Â  raise HTTPException(status_code=400, detail=f"Error fetching payment status: {str(e)}")




@router.post("/payments/refund")
async def refund_payment(payment_id: str, db: Session = Depends(get_db)):
Â  Â  try:
Â  Â  Â  Â  # Assume refund logic is handled by an external payment gateway (PayPal/Stripe)
Â  Â  Â  Â  refund_status = refund_payment_gateway(payment_id) Â # External function for refund

Â  Â  Â  Â  if refund_status != "success":
Â  Â  Â  Â  Â  Â  raise HTTPException(status_code=400, detail="Refund failed")

Â  Â  Â  Â  # Update payment status to 'refunded'
Â  Â  Â  Â  db.execute(
Â  Â  Â  Â  Â  Â  update(tables.payments).where(tables.payments.c.transaction_id == payment_id).values(
Â  Â  Â  Â  Â  Â  Â  Â  payment_status='refunded',
Â  Â  Â  Â  Â  Â  Â  Â  updated_at=datetime.now()
Â  Â  Â  Â  Â  Â  )
Â  Â  Â  Â  )
Â  Â  Â  Â  db.commit()

Â  Â  Â  Â  return {"message": "Payment refunded", "transaction_id": payment_id}

Â  Â  except Exception as e:
Â  Â  Â  Â  raise HTTPException(status_code=400, detail=f"Error processing refund: {str(e)}")


@router.get("/payments/user/{user_id}")
async def get_user_payments(user_id: UUID, db: Session = Depends(get_db)):
Â  Â  try:
Â  Â  Â  Â  # Fetch all payments for the given user
Â  Â  Â  Â  payments = db.execute(
Â  Â  Â  Â  Â  Â  select(tables.payments).where(tables.payments.c.user_id == user_id)
Â  Â  Â  Â  ).fetchall()

Â  Â  Â  Â  if not payments:
Â  Â  Â  Â  Â  Â  raise HTTPException(status_code=404, detail="No payments found for this user")

Â  Â  Â  Â  return {"payments": [dict(payment) for payment in payments]}

Â  Â  except Exception as e:
Â  Â  Â  Â  raise HTTPException(status_code=400, detail=f"Error fetching user payments: {str(e)}")



@router.post("/payments/webhook")
async def payment_webhook(payload: WebhookPayload, db: Session = Depends(get_db)):
Â  Â  try:
Â  Â  Â  Â  # Extract transaction_id from PayPal's webhook payload
Â  Â  Â  Â  payment_id = payload.resource.get('transaction_id') Â # Assuming PayPal sends it under 'resource'
Â  Â  Â  Â  payment_status = payload.resource.get('status')

Â  Â  Â  Â  if not payment_id:
Â  Â  Â  Â  Â  Â  raise HTTPException(status_code=400, detail="No transaction_id found in the webhook payload")

Â  Â  Â  Â  # Update payment status in the database based on transaction_id
Â  Â  Â  Â  db.execute(
Â  Â  Â  Â  Â  Â  update(tables.payments).where(tables.payments.c.transaction_id == payment_id).values(
Â  Â  Â  Â  Â  Â  Â  Â  payment_status=payment_status,
Â  Â  Â  Â  Â  Â  Â  Â  updated_at=datetime.now()
Â  Â  Â  Â  Â  Â  )
Â  Â  Â  Â  )
Â  Â  Â  Â  db.commit()

Â  Â  Â  Â  return {"message": "Payment status updated from webhook", "transaction_id": payment_id}
Â  Â  except Exception as e:
Â  Â  Â  Â  raise HTTPException(status_code=400, detail=f"Error processing webhook: {str(e)}")

